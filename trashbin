
{-
------------------------------------------------------------
UPDATING FUNCTIONS
------------------------------------------------------------
-}





-- handleEvent :: Event -> World -> World
-- handleEvent (EventKey (SpecialKey KeyUp) Down _ _) w = tryMove w UP
-- handleEvent (EventKey (SpecialKey KeyDown) Down _ _) w = tryMove w DOWN
-- handleEvent (EventKey (SpecialKey KeyLeft) Down _ _) w = tryMove w LEFT
-- handleEvent (EventKey (SpecialKey KeyRight) Down _ _) w = tryMove w RIGHT
-- handleEvent _ w = w

-- updateFunc :: Float -> World -> World
-- updateFunc t (World (Player (x, y) dir next (vx, vy)) b)
--   | dir /= next = move (World (Player (x, y) dir next (vx, vy)) b) next t
--   | otherwise = move (World (Player (x, y) dir next (vx, vy)) b) dir t

-- drawFunc :: World -> Picture
-- drawFunc world = Pictures (drawGame world)

-- drawGame :: World -> [Picture]
-- drawGame (World p b) = drawBoard b ++ ((Color black (translate 500 500 (Circle 10))): (Color black ((Circle 10))) : drawPlayer p : [] ) 
-- getNodePics w = drawPlayer w : genCircles (getPoints w)

-- drawPlayer :: Player -> Picture -- todo no offset for now
-- drawPlayer (Player (x, y) _ _ _) = Color black ((translate x y) (Circle 15))
--  where
--     a = x * 100 - 150 -- off set not used right now
--     b = y * 100 - 150

-- drawBoard :: Board -> [Picture]
-- drawBoard (Board []) = [] 
-- drawBoard (Board (t:ts)) = drawTile t : drawBoard (Board (ts))





-- genCircles :: [(Int, Int)] -> [Picture]
-- genCircles [] = []
-- genCircles ((x, y):pts) = Color red (translate a b (Circle 20)) : genCircles pts
--   where
--     a = fromIntegral (x * 100 - 150)
--     b = fromIntegral (y * 100 - 150)

-- getPoints :: World -> [(Int, Int)]
-- getPoints (World _ _ _ (Grid points)) = points


-- data Direction = UP | DOWN | LEFT | RIGHT | NONE
--   deriving (Enum, Eq, Show)

-- getGrid :: Int -> Int -> [(Int, Int)]
-- getGrid l w = [(x, y) | x <- [0..l], y <- [0..w]]


-- tryMove :: World -> Direction -> World
-- tryMove (World (Player pos curr next v) b) dir =   
--   (World (Player pos curr dir v) b)

-- move :: World -> Direction -> Float -> World
-- move (World (Player (x, y) curr next (vx, vy)) b) dir t
--   | validMove (Player (x, y) curr next (vx, vy)) dir b = (World (Player (dx, dy) dir next (getVelocity dir)) b)
--   | otherwise = (World (Player (dx, dy) curr next (vx, vy)) b) -- do nothing
--   where 
--     dx = x + vx * 0.01
--     dy = y + vy * 0.01

-- move (World (Player (x, y) curr next (vx, vy)) b) dir t =
--   (World (Player (dx, dy) dir next (getVelocity dir)) b)
--   where 
--     dx = x + vx * t
--     dy = y + vy * t

{- 
we want to 
(1) see where the player is: Zone -> Node
(2) see if that's a valid direction from there
-}
-- validMove :: Player -> Direction -> Board -> Bool
-- validMove (Player (x, y) _ _ _) dir b =
--   -- do 
--     -- something dirs
--     elem dir dirs 
--   where 
--     currNode = getNode (Point (x, y)) b
--     dirs = getDirs currNode

-- something :: [Direction] -> IO()
-- something dirs = print dirs 

-- getVelocity :: Direction -> (Float, Float)
-- getVelocity dir
--   | dir == UP    = (0.0,  85.0)
--   | dir == DOWN  = (0.0, -85.0)
--   | dir == LEFT  = (-85.0, 0.0)
--   | dir == RIGHT = ( 85.0, 0.0)
--   | otherwise = (0, 0)

-- specialKeyPressed :: Event -> Bool
-- specialKeyPressed (EventKey (Char k) _ _ _) = k == 'g'
-- specialKeyPressed _ = False









{-
POTENTIAL CLEANUP, a little janky, need to to not queue so persistently, but a start

{-
first, if the player currdir /= nextdir, check 
  if they're at close enough to end of their track
    grab the pivot (via player destination) from the board, try to grab the corresponding neighbor from that pivot
    if its null
      instead keep trying to go the same direction as before, can't turn there
      if that is null, stop moving -- keep same location
want to clean this up, works well enough to continue testing, but there's def some gunk to cut out
-}
movePlayer :: Player -> Board -> Player
movePlayer (Player loc (dest, []) curr next) _ = Player loc (dest, [loc]) curr next
movePlayer (Player _ (dest, t:ts) curr next) b
  | curr /= next && closeEnough ts = changeDir (Player t (dest, ts) curr next) b
  | curr == next && needRefill ts = sameDir (Player t (dest, ts) curr curr) b
  | otherwise = Player t (dest, ts) curr next
    


-- queueTracks :: Player -> Board -> Player
-- queueTracks (Player loc (dest, ts) curr next) b -- we are attempting oto queue up the next move
--   | curr /= next = changeDir (Player loc (dest, ts) curr next) b 
--   | otherwise = sameDir (Player loc (dest, ts) curr next) b 

-- todo clean up
changeDir :: Player -> Board -> Player
changeDir (Player loc (Destination point, ts) curr next) b 
  | nextTracks == Null = Player loc (Destination point, ts) curr curr
  | otherwise = Player loc (deconDestination nextTracks, ts ++ deconTracks nextTracks) next next
  where 
    nextPiv = getPivot point b
    nextTracks = getTracks nextPiv next



-- todo clean up
sameDir :: Player -> Board -> Player
sameDir (Player loc (Destination point, ts) curr _) b 
  | nextTracks == Null = Player loc (Destination point, ts) curr curr 
  | otherwise = Player loc (deconDestination nextTracks, ts ++ deconTracks nextTracks) curr curr
  where 
    nextPiv = getPivot point b
    nextTracks = getTracks nextPiv curr

-- sameDir (Player loc (Destination point, []) curr _) _ = Player loc (Destination point, []) curr curr
-- sameDir (Player loc (Destination point, [t]) curr _) b

-- sameDir (Player loc (Destination point, ts) curr next) _ = Player loc (Destination point, ts) curr next

closeEnough :: [a] -> Bool
closeEnough xs = length xs <= 25

needRefill :: [a] -> Bool
needRefill [] = True
needRefill [_] = True
needRefill _ = False

-}